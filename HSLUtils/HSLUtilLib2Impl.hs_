// ======================================================================
// This is a part of the Utility Library 2.
//
// ======================================================================
// Modification History
//
// ======================================================================

#ifndef __HSLUtilLib2Impl_hs___
#define __HSLUtilLib2Impl_hs___ 1

#ifdef HSL_RUNTIME
#pragma once
   #include "HSLStrLib/HSLStrLib.hsl"
   #include "HSLMthLib/HSLMthLib.hsl"
   #include "HSLSynLib/HSLSynLib.hsl"
   #include "HSLErrLib/HSLErrLib.hsl"
   #include "HSLUtils/HSLUtilLib2Def.hs_"
   #include "HSLUtils/HSLUtilLib.hsl"

// ----------------------------------------------------------------------------------------------------
// Debug switches
// ----------------------------------------------------------------------------------------------------

//#define DEBUG_Util2     1      // Base debug traces
//#define DEBUG_Util2Ex   1      // Extended debug traces (e.g. arrays / sequences)

namespace Util2
{
   // ----------------------------------------------------------------------------------------------------
   // Data 
   // ----------------------------------------------------------------------------------------------------

   // None

   // ----------------------------------------------------------------------------------------------------
   // Constants
   // ----------------------------------------------------------------------------------------------------

   namespace Constants
   {
      static const variable ModuleName("HSLUtilLib2");      // Used to generate the help-file name used during runtime
      static const variable HelpFileExtension(".chm");      // Used to generate the help-file name used during runtime
      static const variable VolumePrecision(1);             // Count of digits after decimal used to round any volume values zero may be used to round for zero digits.
      static variable TraceArrayIndexWidth(4);              // The width of the index field in the TraceArray_X() functions
      static variable TraceArrayElementWidth(25);           // The width of an element field in the TraceArray_X() functions
   }

   // ----------------------------------------------------------------------------------------------------
   // Translated strings
   // ----------------------------------------------------------------------------------------------------

   namespace TrStr
   {
      static const variable ValueCheck_CheckedValue                     (Translate("Inspected value: '%s1' (is of type '%s2')"));
      static const variable ValueCheck_ExpectedType                     (Translate("Expected type: '%s1'"));

      static const variable ValueCheck_TypeInteger                      (Translate("integer number"));
      static const variable ValueCheck_TypeFloat                        (Translate("decimal number"));
      static const variable ValueCheck_TypeString                       (Translate("string value"));              
      static const variable ValueCheck_TypeNULL                         (Translate("no type (null)"));               

      static const variable ValueCheck_RangeCheckedValue                (Translate("Inspected value: '%s1'"));
      static const variable ValueCheck_RangeExpected                    (Translate("Expected range: '%s1'"));
      static const variable ValueCheck_RangeExpectedMinMax              (Translate("Expected range: minimum='%s1', maximum='%s2'"));
      static const variable ValueCheck_RangeExpectedMinMaxString        (Translate("Expected count of characters: minimum='%s1', maximum='%s2'"));

      static const variable ValueCheck_RangeStringEmpty                 (Translate("empty string"));
      static const variable ValueCheck_RangeStringNotEmpty              (Translate("not empty string"));
      static const variable ValueCheck_RangeNumberNotZero               (Translate("not equal to zero"));
      static const variable ValueCheck_RangeNumberEqualToZero           (Translate("equal to zero"));
      static const variable ValueCheck_RangeNumberLessOrEqualToZero     (Translate("less than or equal to zero"));
      static const variable ValueCheck_RangeNumberLessOrEqualToMinusOne (Translate("less than or equal to minus one"));
      static const variable ValueCheck_RangeNumberLessThanZero          (Translate("less than zero"));
      static const variable ValueCheck_RangeNumberGreaterThanZero       (Translate("greater than zero"));
      static const variable ValueCheck_RangeNumberGreaterOrEqualToZero  (Translate("greater or equal to zero"));
      static const variable ValueCheck_RangeNumberGreaterOrEqualToOne   (Translate("greater or equal to one"));
      static const variable ValueCheck_RangeInvalid                     (Translate("The passed range to check is invalid!"));

      static const variable DebugDEBUG                                  (Translate("DEBUG"));
      static const variable DebugName                                   (Translate("Name"));
      static const variable DebugCurrent                                (Translate("Current"));
      static const variable DebugEnd                                    (Translate("End"));
      static const variable DebugTotal                                  (Translate("Total"));
      static const variable DebugElement                                (Translate("Element"));
      static const variable DebugErrorMustHaveSameSize1                 (Translate("Error: Sequence(s) and array(s) must have same size."));
      static const variable DebugEmptySequences                         (Translate("Empty sequence(s) and array(s)."));
      static const variable DebugSequence                               (Translate("Sequence"));
      static const variable DebugEmptyArray                             (Translate("Empty array(s)."));
      static const variable DebugErrorMustHaveSameSize2                 (Translate("Error: Array(s) must have same size."));

      static const variable ArrayIndexNotANumber                        (Translate("Index of array '%s1' must be a positive integer number (actual type of array index is '%s2')."));
      static const variable ArrayIndexNotAnInteger                      (Translate("Index of array '%s1' must be a positive integer number (actual type of array index is '%s2')."));
      static const variable ArrayIndexMustNotBeNegative                 (Translate("Index of array '%s1' must be greater than or equal to one (actual value of array index is '%s2')."));
      static const variable ArrayIndexMustNotBeGreaterThanArraySize     (Translate("Index of array '%s1' must be less than or equal to the size of the array (actual value of array index is '%s2', actual size of array is '%s3')."));

      static const variable TypeInteger                                 (Translate("integer"));
      static const variable TypeFloat                                   (Translate("float"));
      static const variable TypeString                                  (Translate("string"));
      static const variable TypeNull                                    (Translate("null"));
   }

   // ----------------------------------------------------------------------------------------------------
   // Traceing
   // ----------------------------------------------------------------------------------------------------

   namespace TraceStatus
   {
      static const variable start(1);                       // action status for formated trace
      static const variable complete(2);                    // action status for formated trace
      static const variable error_(3);                      // action status for formated trace
      static const variable progress(4);                    // action status for formated trace
      static const variable completeWithError(5);           // action status for formated trace
   }

   // ----------------------------------------------------------------------------------------------------
   // Functions
   // ----------------------------------------------------------------------------------------------------

   namespace Error
   {
      static const variable MajorID(0x63);                  // Major error id

      namespace MinorID    // Minor error ids
      {
         static const variable GeneralRuntimeError(0x01);
         //static const variable ....(0x1F)
      }

      namespace ErrorCode  // Error codes
      {
         static const variable Unexpected                   (0x0001);
         static const variable InvalidParameter             (0x0002);
         static const variable ValueCheckFailedType         (0x0003);
         static const variable ValueCheckFailedRange        (0x0004);
         static const variable LabwareError                 (0x0005);
         static const variable ArrayIndexNotANumber         (0x0006);
         static const variable ArrayIndexNotAnInteger       (0x0007);
         static const variable ArrayIndexMustNotBeNegative  (0x0008);
         static const variable ArrayIndexMustNotBeGreaterThanArraySize(0x0009);

         //static const variable ....(0xFFFF)               // If a new ErrorCode is added the function Error::MakeErrorDescription()
                                                            // must be extended also by a mapping to the error text
      }

      namespace TrStr      // Translated error strings
      {
         static const variable Unexpected                   (Translate("Unexpected error."));
         static const variable InvalidParameter             (Translate("The parameter is invalid:"));
         static const variable ValueCheckFailedType         (Translate("Check of value failed!\nA value passed to function or read from a file has an invalid type."));
         static const variable ValueCheckFailedRange        (Translate("Check of value failed!\nA value passed to function or read from a file is not within the expected range."));
         static const variable LabwareError                 (Translate("Error during access of data for labware (LabwareId/PositonId)."));
         static const variable NoErrorTextAvailable         (Translate("No error description available."));
      }

      // ----------------------------------------------------------------------------------------------------
      // Error functions
      // ----------------------------------------------------------------------------------------------------

      static function MakeErrorDescription(
         variable errorCode,
         variable& additionalDescr) variable
      {
         variable description("");
         variable errorNumber(0);

         if (         ErrorCode::Unexpected == errorCode )
            description = TrStr::Unexpected;
         else if (    ErrorCode::InvalidParameter == errorCode )
            description = TrStr::InvalidParameter;
         else if (    ErrorCode::ValueCheckFailedType == errorCode )
            description = TrStr::ValueCheckFailedType;
         else if (    ErrorCode::ValueCheckFailedRange == errorCode )
            description = TrStr::ValueCheckFailedRange;
         else if (    ErrorCode::LabwareError == errorCode )
            description = TrStr::LabwareError;
         else if (    ErrorCode::ArrayIndexNotANumber == errorCode )
            description = TrStr::ArrayIndexNotANumber;
         else if (    ErrorCode::ArrayIndexNotAnInteger == errorCode )
            description = TrStr::ArrayIndexNotAnInteger;
         else if (    ErrorCode::ArrayIndexMustNotBeNegative == errorCode )
            description = TrStr::ArrayIndexMustNotBeNegative;
         else if (    ErrorCode::ArrayIndexMustNotBeGreaterThanArraySize == errorCode )
            description = TrStr::ArrayIndexMustNotBeGreaterThanArraySize;
         //...    
         //...
         //... To be extended if a new errorCode's are added
         //...
         //...
         else
         {
            description = TrStr::NoErrorTextAvailable;
         }

         // Generate the full description
         if ( additionalDescr != "" )
         {
            description = description + "\n\n"+additionalDescr;
         }
         return(description);
      }

      static function MakeHxResult(
            variable major,
            variable minor,
            variable code) variable
      {
         variable hxResult(0);

         // Check input params to be valid.
         // Calling function Error::RaiseRuntimeError() here, raises the runtime error 'recursive or concurrent function call',
         // --> fall through input params check.

         // Make HxResult
         hxResult = MthShiftLeft(minor & 0x1F, 24) | MthShiftLeft(major & 0xFF, 16) | (code & 0xFFFF);

         #ifdef DEBUG_Util2
            FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "major=", major, ", minor=", minor, ", code=", code, " -> HxResult=", hxResult);
         #endif

         return( hxResult );
      }

      static function RaiseRuntimeError(
         variable majorID,
         variable minorID,
         variable errorCode,
         variable& errorDescription,
         variable& helpFileName,
         variable& fileName,
         variable& functionName,
         variable& lineNumber) void
      {
         variable errorNumber(0);
         variable description("");

         description = fileName + "(" + lineNumber + ") : " + functionName + "().\n\n" + errorDescription;
         err.SetDescription(description);

         // Raise error
         err.Raise(MakeHxResult(majorID, minorID, errorCode), err.GetDescription(), helpFileName);
      }

      static function RaiseLast() void
      {
         // re-raise error
         err.Raise();
      }

      static function RaiseRuntimeErrorInclPrevErrDesc(
         variable majorID,
         variable minorID,
         variable errorCode,
         variable& errorDescription,
         variable& helpFileName,
         variable& fileName,
         variable& functionName,
         variable& lineNumber) void
      {
         if ( Err::ErrMajor(err.GetId()) != MajorID )
         {  
            // Error not generated from this file e.g. EOF-error,
            // generate error with ID from this module, include error text from previous error

            variable extendedDescr;
            extendedDescr = "--------------------\n" + err.GetDescription() + "--------------------";
            if ( errorDescription != "" )
            {
               extendedDescr = errorDescription + "\n\n" + extendedDescr;
            }

            RaiseRuntimeError(majorID, minorID, errorCode, extendedDescr, helpFileName, fileName, functionName, lineNumber);
         }
         else
         {
            // The currenly set error is already from this module, re-raise
            RaiseLast();
         }
      }
   }

   // ----------------------------------------------------------------------------------------------------
   // Utility functions
   // ----------------------------------------------------------------------------------------------------

   static function ToString(variable var) variable
   {
      variable type;

      type = GetType(var);
      if (hslInteger.Compare(type) == 0)
      {
         var = IStr(var);
      }
      else
      {
         if (hslFloat.Compare(type) == 0)
         {
            var = FStr(var);
         }
         else
         {
            if (hslString.Compare(type) != 0)
            {
               // has no type, return an empty string
               var = "";
            }
         }
      }
      return(var);
   }

   static function ToFixedWidthString(variable var, variable width) variable
   {
      variable varStr("");

      varStr = ToString(var);
      Str::StrFillRight(varStr, " ", width);
      return(varStr);
   }

   static function GetModuleHelpFileName() variable
   {
      variable helpFile("");
      variable thisFilePath("");
      variable lastBackSlashPos(-1);

      // Note: The help for this library must be located in same directory as this file.
      // Evaluate the path to concatniate it with the MolduleName+Extension.
      thisFilePath = GetFileName();
      lastBackSlashPos = Str::StrReverseFind(thisFilePath, "\\");
      if ( -1 < lastBackSlashPos )
      {
         thisFilePath = Str::StrLeft(thisFilePath, lastBackSlashPos+1);
      }

      helpFile = thisFilePath + Constants::ModuleName + GetLanguage() + Constants::HelpFileExtension;    // current language
      if ("" == SearchPath(helpFile))
      {
         helpFile = thisFilePath + Constants::ModuleName + "Enu" + Constants::HelpFileExtension;         // default language, fixed to enu
         if ("" == SearchPath(helpFile))
         {
            helpFile = thisFilePath + Constants::ModuleName + Constants::HelpFileExtension;              // no language
            if ("" == SearchPath(helpFile))
            {
               // no help file found within the search directory
               // return the helpFileName with current language, but without path.
               // Maybe its existing/found at other place or its registered and found by this way.
               helpFile = Constants::ModuleName + GetLanguage() + Constants::HelpFileExtension;
            }
         }
      }
      
      #ifdef DEBUG_Util2
         FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "Module Help File: ", helpFile);
      #endif

      return( helpFile );
   }

   static function CheckValueType(
      variable& valueToCheck,                // io:
      variable& typeToCheck,                 // i:
      variable& addErrorDescription) void    // i:
   {
      string valueType("");

      // Check input params to be valid
      if (!Util::IsString(typeToCheck))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter,
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "typeToCheck"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (ValueType::Integer != typeToCheck && ValueType::Float != typeToCheck && ValueType::String != typeToCheck)
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter,
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "typeToCheck"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (!Util::IsString(addErrorDescription))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter,
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "addErrorDescription"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }

      // Check value type to be valid
      valueType = GetType(valueToCheck);

      if ( (hslFloat.Compare(typeToCheck) == 0) && (valueType.Compare(hslInteger) == 0) )
      {
         // We have an integer in hand but it should be checked as float
         // Convert the in/out parameter to float.
         valueToCheck = valueToCheck * 1.0;
         valueType = GetType(valueToCheck);     // must be hslFloat now
      }

      if ( valueType.Compare(typeToCheck) != 0 )
      {
         // The value is not of same type as we must check, raise an error
         variable strValueType, strCheckType;
         variable strErrText, strTemp;

         if ( valueType.Compare(hslInteger) == 0 )
            strValueType = TrStr::ValueCheck_TypeInteger;
         else if ( valueType.Compare(hslFloat) == 0 )
            strValueType = TrStr::ValueCheck_TypeFloat;
         else if ( valueType.Compare(hslString) == 0 )
            strValueType = TrStr::ValueCheck_TypeString;
         else
            strValueType = TrStr::ValueCheck_TypeNULL;

         if ( hslInteger.Compare(typeToCheck) == 0 )
            strCheckType = TrStr::ValueCheck_TypeInteger;
         else if ( hslFloat.Compare(typeToCheck) == 0 )
            strCheckType = TrStr::ValueCheck_TypeFloat;
         else if ( hslString.Compare(typeToCheck) == 0 )
            strCheckType = TrStr::ValueCheck_TypeString;
         else
            strValueType = TrStr::ValueCheck_TypeNULL;

         strTemp = TrStr::ValueCheck_CheckedValue;
         Str::StrReplace(strTemp, "%s1", ToString(valueToCheck));
         Str::StrReplace(strTemp, "%s2", strValueType);
         strErrText = strTemp;

         strTemp = TrStr::ValueCheck_ExpectedType;
         Str::StrReplace(strTemp, "%s1", strCheckType);
         strErrText = strErrText + "\n" + strTemp;

         strErrText = strErrText + "\n\n" + addErrorDescription;

         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ValueCheckFailedType,
                                 Error::MakeErrorDescription(Error::ErrorCode::ValueCheckFailedType, strErrText), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }

   static function CheckValueRange(
      variable& valueToCheck,                // i:
      variable rangeToCheck,                 // i:
      variable& addErrorDescription) void    // i:
   {
      variable valueType, rangeCheckFailed, rangeCheckErrorText;

      // Check input params to be valid
      if (!Util::IsInteger(rangeToCheck))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter,
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "rangeToCheck"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (rangeToCheck < ValueCheck::First || ValueCheck::Last < rangeToCheck)
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "rangeToCheck"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (!Util::IsString(addErrorDescription))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "addErrorDescription"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }

      // Check value range to be valid
      valueType = GetType(valueToCheck);

      if ( ValueCheck::RangeNoCheck == rangeToCheck )
      {
         // No range check to perform
         return;
      }

      rangeCheckFailed = hslFalse;
      if ( hslString.Compare(valueType) == 0 )
      {
         if ( ValueCheck::RangeStringEmpty == rangeToCheck )
         {
            if ( Str::StrGetLength(valueToCheck) != 0 )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeStringEmpty;
            }
         }
         else if ( ValueCheck::RangeStringNotEmpty == rangeToCheck )
         {
            if ( Str::StrGetLength(valueToCheck) < 1 )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeStringNotEmpty;
            }
         }
         else
         {
            // unexpected range specified.
            rangeCheckFailed = hslTrue;
            rangeCheckErrorText = TrStr::ValueCheck_RangeInvalid;
         }
      }
      else if ( hslInteger.Compare(GetType(valueToCheck)) == 0 || hslFloat.Compare(GetType(valueToCheck)) == 0 )
      {
         // float or integer
         if ( ValueCheck::RangeNumberNotZero == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck != 0) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck != 0.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberNotZero;
            }
         }
         else if ( ValueCheck::RangeNumberEqualToZero == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck == 0) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck == 0.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberEqualToZero;
            }
         }
         else if ( ValueCheck::RangeNumberLessOrEqualToZero == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck <= 0) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck <= 0.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberLessOrEqualToZero;
            }
         }
         else if ( ValueCheck::RangeNumberLessOrEqualToMinusOne == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck <= -1) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck <= -1.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberLessOrEqualToMinusOne;
            }
         }
         else if ( ValueCheck::RangeNumberLessThanZero == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck < 0) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck < 0.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberLessThanZero;
            }
         }
         else if ( ValueCheck::RangeNumberGreaterThanZero == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck > 0) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck > 0.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberGreaterThanZero;
            }
         }
         else if ( ValueCheck::RangeNumberGreaterOrEqualToZero == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck >= 0) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck >= 0.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberGreaterOrEqualToZero;
            }
         }
         else if ( ValueCheck::RangeNumberGreaterOrEqualToOne == rangeToCheck )
         {
            if (     ( hslInteger.Compare(valueType) == 0 && !(valueToCheck >= 1) )
                  || ( hslFloat.Compare(valueType)   == 0 && !(valueToCheck >= 1.0) ) )
            {
               rangeCheckFailed = hslTrue;
               rangeCheckErrorText = TrStr::ValueCheck_RangeNumberGreaterOrEqualToOne;
            }
         }
         else
         {
            // unexpected range specified.
            rangeCheckFailed = hslTrue;
            rangeCheckErrorText = TrStr::ValueCheck_RangeInvalid;
         }
      }
      else
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::Unexpected, 
                                 Error::MakeErrorDescription(Error::ErrorCode::Unexpected, Translate("Unexpected type of variable (NULL)")), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }

      if ( rangeCheckFailed )
      {
         variable strErrText, strTemp;

         strTemp = TrStr::ValueCheck_RangeCheckedValue;
         Str::StrReplace(strTemp, "%s1", ToString(valueToCheck));
         strErrText = strTemp;

         strTemp = TrStr::ValueCheck_RangeExpected;
         Str::StrReplace(strTemp, "%s1", rangeCheckErrorText);
         strErrText = strErrText + "\n" + strTemp;

         strErrText = strErrText + "\n\n" + addErrorDescription;

         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ValueCheckFailedRange, 
                                 Error::MakeErrorDescription(Error::ErrorCode::ValueCheckFailedRange, strErrText), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }

   static function CheckValueRangeMinMax(
      variable& valueToCheck,                // i:
      variable minValue,                     // i:
      variable maxValue,                     // i:
      variable& addErrorDescription) void    // i:
   {

      // Check input params to be valid
      if (!Util::IsNumber(minValue))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "minValue"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (!Util::IsNumber(maxValue))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "maxValue"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (maxValue < minValue)
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "maxValue"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (!Util::IsString(addErrorDescription))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "addErrorDescription"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }

      // Check value range to be valid
      if ( hslString.Compare(GetType(valueToCheck)) == 0 )
      {
         if (Str::StrGetLength(valueToCheck) < minValue || Str::StrGetLength(valueToCheck) > maxValue )
         {
            variable strErrText, strTemp;

            strTemp = TrStr::ValueCheck_RangeCheckedValue;
            Str::StrReplace(strTemp, "%s1", ToString(valueToCheck));
            strErrText = strTemp;

            strTemp = TrStr::ValueCheck_RangeExpectedMinMaxString;
            Str::StrReplace(strTemp, "%s1", ToString(minValue));
            Str::StrReplace(strTemp, "%s2", ToString(maxValue));
            strErrText = strErrText + "\n" + strTemp;

            strErrText = strErrText + "\n\n" + addErrorDescription;

            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ValueCheckFailedRange, 
                                    Error::MakeErrorDescription(Error::ErrorCode::ValueCheckFailedRange, strErrText), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }
      }
      else if ( hslInteger.Compare(GetType(valueToCheck)) == 0 || hslFloat.Compare(GetType(valueToCheck)) == 0 )
      {
         if (valueToCheck < minValue || valueToCheck > maxValue )
         {
            variable strErrText, strTemp;

            strTemp = TrStr::ValueCheck_RangeCheckedValue;
            Str::StrReplace(strTemp, "%s1", ToString(valueToCheck));
            strErrText = strTemp;

            strTemp = TrStr::ValueCheck_RangeExpectedMinMax;
            Str::StrReplace(strTemp, "%s1", ToString(minValue));
            Str::StrReplace(strTemp, "%s2", ToString(maxValue));
            strErrText = strErrText + "\n" + strTemp;

            strErrText = strErrText + "\n\n" + addErrorDescription;

            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ValueCheckFailedRange, 
                                    Error::MakeErrorDescription(Error::ErrorCode::ValueCheckFailedRange, strErrText), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }
      }
      else
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::Unexpected, 
                                 Error::MakeErrorDescription(Error::ErrorCode::Unexpected, Translate("Unexpected type of variable (NULL)")), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }


   static function CheckValueTypeAndRange(
      variable& valueToCheck,             // io:
      variable& typeToCheck,              // i:
      variable rangeToCheck,              // i:
      variable& addErrorDescription) void // i:
   {
      CheckValueType(valueToCheck, typeToCheck, addErrorDescription);
      CheckValueRange(valueToCheck, rangeToCheck, addErrorDescription);
   }

   static function CheckValueTypeAndRangeMinMax(
      variable& valueToCheck,                // io:
      variable& typeToCheck,                 // i:
      variable  minValue,                    // i:
      variable  maxValue,                    // i:
      variable& addErrorDescription) void    // i:
   {
      CheckValueType(valueToCheck, typeToCheck, addErrorDescription);
      CheckValueRangeMinMax(valueToCheck, minValue, maxValue, addErrorDescription);
   }

   static function RoundVolume(variable& volume) void
   {
      volume = MthRound(volume, Constants::VolumePrecision);
   }

   static function RoundVolumeUp(variable& volume) void
   {
      volume = volume + 0.49999999 * (10^(-Constants::VolumePrecision));      // don't use 0.5000 because this rounds 300.0 to 300.1 (precission 1)
      RoundVolume(volume);
   }

   static function RoundVolumeDown(variable& volume) void
   {
      volume = volume - 0.49999999 * (10^(-Constants::VolumePrecision));      // don't use 0.5000 because this rounds 300.0 to 299.9 (precission 1)
      RoundVolume(volume);
   }


   static function GetLabwarePosXYZ(
      device    deviceObj,    // i:
      variable& labwareId,    // i:
      variable& positionId,   // i:
      variable& xCoord,       // o:
      variable& yCoord,       // o:
      variable& zCoord) void  // o:
   {
      variable arrPos[];

      onerror goto LabwareError;

      xCoord=-1; yCoord=-1; zCoord=-1;

      if ( 0 == deviceObj.GetLabwarePosition(labwareId, arrPos, positionId) )
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::Unexpected, 
                                 Error::MakeErrorDescription(Error::ErrorCode::Unexpected, "GetLabwarePosition"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }

      xCoord = arrPos[0];
      yCoord = arrPos[1];
      zCoord = arrPos[2];

      #ifdef DEBUG_Util2
         FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
                     "LabID/PosID=", labwareId, "/", positionId, ": xCoord=", xCoord, ", yCoord=", yCoord, ", zCoord=", zCoord);
      #endif      

      return;

      // --------------------------------------------------------
      LabwareError:
      {
         Error::RaiseRuntimeErrorInclPrevErrDesc(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::LabwareError, 
                                                   Error::MakeErrorDescription(Error::ErrorCode::LabwareError, ""), 
                                                   GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }

   // --------------------------------------------------------------------------------------
   // Array index checking
   // --------------------------------------------------------------------------------------

   static function CheckArrayIndex(
      variable size,
      variable index,
      variable& arrayName) void
   {
      variable type("");

      // check index to be valid
      type = GetType(index);
      if (hslString.Compare(type) == 0)
      {
         // Index of array '%s1' must be a positive integer number (actual type of array index is '%s2').
         variable errorDesc;
         errorDesc = TrStr::ArrayIndexNotANumber;
         Str::StrReplace(errorDesc, "%s1", arrayName);
         Str::StrReplace(errorDesc, "%s2", TrStr::TypeString);
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ArrayIndexNotANumber, 
                                 errorDesc,     // Don't use Error::MakeErrorDescription
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (hslFloat.Compare(type) == 0)
      {
         // Index of array '%s1' must be a positive integer number (actual type of array index is '%s2').
         variable errorDesc;
         errorDesc = TrStr::ArrayIndexNotAnInteger;
         Str::StrReplace(errorDesc, "%s1", arrayName);
         Str::StrReplace(errorDesc, "%s2", TrStr::TypeFloat);
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ArrayIndexNotAnInteger, 
                                 errorDesc,     // Don't use Error::MakeErrorDescription
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if ("" == type)
      {
         // Index of array '%s1' must be a positive integer number (actual type of array index is '%s2').
         variable errorDesc;
         errorDesc = TrStr::ArrayIndexNotANumber;
         Str::StrReplace(errorDesc, "%s1", arrayName);
         Str::StrReplace(errorDesc, "%s2", TrStr::TypeNull);
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ArrayIndexNotANumber, 
                                 errorDesc,     // Don't use Error::MakeErrorDescription
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (index <= 0)
      {
         // Index of array '%s1' must be greater than or equal to one (actual value of array index is '%s2').
         variable errorDesc;
         errorDesc = TrStr::ArrayIndexMustNotBeNegative;
         Str::StrReplace(errorDesc, "%s1", arrayName);
         Str::StrReplace(errorDesc, "%s2", IStr(index));
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ArrayIndexMustNotBeNegative, 
                                 errorDesc,     // Don't use Error::MakeErrorDescription
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      if (size < index)
      {
         // Index of array '%s1' must be smaller than the size of the array (actual value of array index is '%s2').
         variable errorDesc;
         errorDesc = TrStr::ArrayIndexMustNotBeGreaterThanArraySize;
         Str::StrReplace(errorDesc, "%s1", arrayName);
         Str::StrReplace(errorDesc, "%s2", IStr(index));
         Str::StrReplace(errorDesc, "%s3", IStr(size));
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::ArrayIndexMustNotBeGreaterThanArraySize, 
                                 errorDesc,     // Don't use Error::MakeErrorDescription
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }

   static function VarArrCheckIndex(
      variable& varArray[],
      variable index,
      variable& varArrayName) void
   {
      // check index to be valid
      CheckArrayIndex(varArray.GetSize(), index, varArrayName);

      // check other params to be valid
      if (!Util::IsString(varArrayName))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "varArrayName"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }

   static function SeqArrCheckIndex(
      sequence& seqArray[],
      variable index,
      variable& seqArrayName) void
   {
      // check index to be valid
      CheckArrayIndex(seqArray.GetSize(), index, seqArrayName);

      // check other params to be valid
      if (!Util::IsString(seqArrayName))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "seqArrayName"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
   }

   static function VarArrGetAt(
      variable& varArray[],
      variable index,
      variable& varArrayName) variable
   {
      // check index to be valid
      CheckArrayIndex(varArray.GetSize(), index, varArrayName);

      // check other params to be valid
      if (!Util::IsString(varArrayName))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "varArrayName"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }

      return(varArray.GetAt(index - 1));
   }

   static function SeqArrGetAt(
      sequence& seqArray[],
      variable index,
      variable& seqArrayName) sequence
   {
      // check index to be valid
      CheckArrayIndex(seqArray.GetSize(), index, seqArrayName);

      // check other params to be valid
      if (!Util::IsString(seqArrayName))
      {
         Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                 Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "seqArrayName"), 
                                 GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
      }
      
      return(seqArray.GetAt(index - 1));
   }

   // ----------------------------------------------------------------------------------------------------
   // Debug functions
   // ----------------------------------------------------------------------------------------------------

   namespace Debug
   {
      static function TraceSequence(sequence& sequenceObj) void
      {
         variable index(0), size(0);
         variable currentBackup(-1);

         currentBackup = sequenceObj.GetCurrentPosition();

         size = sequenceObj.GetTotal();
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugName, ": '", sequenceObj.GetName(), "', ", TrStr::DebugCurrent, ": ", currentBackup, ", ", TrStr::DebugEnd, ": ", sequenceObj.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         for (index=0; index<size; index++)
         {
            sequenceObj.SetCurrentPosition(index+1);
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugElement, " " + IStr(index+1), ": ", sequenceObj.GetLabwareId(), ".", sequenceObj.GetPositionId());
         }

         sequenceObj.SetCurrentPosition(currentBackup);
      }

      static function TraceSequenceAndData_1(
            variable& description,
            sequence& sequenceObj,
            variable& array[]) void
      {
         variable index(0), size(0);
         variable currentBackup(-1);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace sequence and data
         currentBackup = sequenceObj.GetCurrentPosition();

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = sequenceObj.GetTotal();
         if ( size != array.GetSize())
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize1);
            return;
         }

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugSequence, ": ", TrStr::DebugCurrent, ": ", currentBackup, ", ", TrStr::DebugEnd, ": ", sequenceObj.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptySequences);
         }

         for (index=0; index<size; index++)
         {
            sequenceObj.SetCurrentPosition(index+1);
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugElement, " ", IStr(index+1), ": ", sequenceObj.GetLabwareId(), ".", sequenceObj.GetPositionId(),
                                                                           " / array[", index + 1, "]=", array[index]);
         }
      
         sequenceObj.SetCurrentPosition(currentBackup);
      }

      static function TraceSequenceAndData_2(
            variable& description,
            sequence& sequenceObj,
            variable& array_1[],
            variable& array_2[]) void
      {
         variable index(0), size(0);
         variable currentBackup(-1);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace sequence and data
         currentBackup = sequenceObj.GetCurrentPosition();

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = sequenceObj.GetTotal();
         if ( size != array_1.GetSize() || size != array_1.GetSize())
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize1);
            return;
         }

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugSequence, ": ", TrStr::DebugCurrent, ": ", currentBackup, ", ", TrStr::DebugEnd, ": ", sequenceObj.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptySequences);
         }

         for (index=0; index<size; index++)
         {
            sequenceObj.SetCurrentPosition(index+1);
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugElement, " ", IStr(index+1), ": ", sequenceObj.GetLabwareId(), ".", sequenceObj.GetPositionId(),
                                                                           " / array_1[", index + 1, "]=", array_1[index], " / array_2[", index + 1, "]=", array_2[index]);
         }
      
         sequenceObj.SetCurrentPosition(currentBackup);
      }

      static function TraceSequencesAndData_2(
            variable& description,
            sequence& sequenceObj_1,
            sequence& sequenceObj_2,
            variable& array_1[],
            variable& array_2[]) void
      {
         variable index(0), size(0);
         variable currentBackup1(-1), currentBackup2(-1);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace sequence and data
         currentBackup1 = sequenceObj_1.GetCurrentPosition();
         currentBackup2 = sequenceObj_2.GetCurrentPosition();

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = sequenceObj_1.GetTotal();
         if ( size != array_1.GetSize() || size != array_2.GetSize() || size != sequenceObj_2.GetTotal() )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize1);
            return;
         }

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugSequence, " 1: ", TrStr::DebugCurrent, ": ", currentBackup1, ", ", TrStr::DebugEnd, ": ", sequenceObj_1.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugSequence, " 2: ", TrStr::DebugCurrent, ": ", currentBackup2, ", ", TrStr::DebugEnd, ": ", sequenceObj_2.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptySequences);
         }

         for (index=0; index<size; index++)
         {
            sequenceObj_1.SetCurrentPosition(index+1);
            sequenceObj_2.SetCurrentPosition(index+1);
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugElement, " ", IStr(index+1), ": sequence_1=", sequenceObj_1.GetLabwareId(), ".", sequenceObj_1.GetPositionId(),
                                                                           " / sequence_2=", sequenceObj_2.GetLabwareId(), ".", sequenceObj_2.GetPositionId(),
                                                                           " / array_1[", index + 1, "]=", array_1[index], " / array_2[", index + 1, "]=", array_2[index]);
         }
      
         sequenceObj_1.SetCurrentPosition(currentBackup1);
         sequenceObj_2.SetCurrentPosition(currentBackup2);
      }

      static function TraceSequencesAndData_1(
            variable& description,
            sequence& sequenceObj_1,
            sequence& sequenceObj_2,
            variable& array[]) void
      {
         variable index(0), size(0);
         variable currentBackup1(-1), currentBackup2(-1);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace sequence and data
         currentBackup1 = sequenceObj_1.GetCurrentPosition();
         currentBackup2 = sequenceObj_2.GetCurrentPosition();

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = sequenceObj_1.GetTotal();
         if ( size != array.GetSize() || size != sequenceObj_2.GetTotal() )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize1);
            return;
         }

         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugSequence, " 1: ", TrStr::DebugCurrent, ": ", currentBackup1, ", ", TrStr::DebugEnd, ": ", sequenceObj_1.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugSequence, " 2: ", TrStr::DebugCurrent, ": ", currentBackup2, ", ", TrStr::DebugEnd, ": ", sequenceObj_2.GetCount(), ", ", TrStr::DebugTotal, ": ", size);
         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptySequences);
         }

         for (index=0; index<size; index++)
         {
            sequenceObj_1.SetCurrentPosition(index+1);
            sequenceObj_2.SetCurrentPosition(index+1);
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugElement, " ", IStr(index+1), ": sequence_1=", sequenceObj_1.GetLabwareId(), ".", sequenceObj_1.GetPositionId(),
                                                                           " / sequence_2=", sequenceObj_2.GetLabwareId(), ".", sequenceObj_2.GetPositionId(),
                                                                           " / array[", index + 1, "]=", array[index]);
         }
      
         sequenceObj_1.SetCurrentPosition(currentBackup1);
         sequenceObj_2.SetCurrentPosition(currentBackup2);
      }

      function SetTraceArraySettings(variable indexWidth, variable elementWidth) void
      {
         // Check input params to be valid
         if (!Util::IsInteger(indexWidth))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "indexWidth"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }
         if (Util::IsNegative(indexWidth))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "indexWidth"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }
         if (!Util::IsInteger(elementWidth))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "elementWidth"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }
         if (Util::IsNegative(elementWidth))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "elementWidth"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Set trace array settings
         Constants::TraceArrayIndexWidth = indexWidth;
         Constants::TraceArrayElementWidth = elementWidth;
      }

      static function TraceArray(variable& description, variable& array[]) void
      {
         variable index(0), size(0);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace array
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = array.GetSize();
         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptyArray);
         }

         for (index=0; index<size; index++)
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, "[", index + 1, "]: ", array[index]);
         }
      }


      static function TraceArray_2(variable& description, variable& array_1[], variable& array_2[]) void
      {
         variable index(0), size(0);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace arrays
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = array_1.GetSize();
         if ( size != array_2.GetSize() )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize2);
            return;
         }

         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptyArray);
         }

         for (index=0; index<size; index++)
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, 
                        "[", ToFixedWidthString(index + 1, Constants::TraceArrayIndexWidth), "]: ", 
                        ToFixedWidthString(array_1[index], Constants::TraceArrayElementWidth), " ",
                        ToFixedWidthString(array_2[index], Constants::TraceArrayElementWidth));
         }
      }


      static function TraceArray_3(variable& description, variable& array_1[], variable& array_2[], variable& array_3[]) void
      {
         variable index(0), size(0);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace arrays
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = array_1.GetSize();
         if ( size != array_2.GetSize() || size != array_3.GetSize())
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize2);
            return;
         }

         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptyArray);
         }

         for (index=0; index<size; index++)
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, 
                        "[", ToFixedWidthString(index + 1, Constants::TraceArrayIndexWidth), "]: ", 
                        ToFixedWidthString(array_1[index], Constants::TraceArrayElementWidth), " ",
                        ToFixedWidthString(array_2[index], Constants::TraceArrayElementWidth), " ", 
                        ToFixedWidthString(array_3[index], Constants::TraceArrayElementWidth));
         }
      }

      static function TraceArray_4(variable& description, variable& array_1[], variable& array_2[], variable& array_3[], variable& array_4[]) void
      {
         variable index(0), size(0);

         // Check input params to be valid
         if (!Util::IsString(description))
         {
            Error::RaiseRuntimeError(Error::MajorID, Error::MinorID::GeneralRuntimeError, Error::ErrorCode::InvalidParameter, 
                                    Error::MakeErrorDescription(Error::ErrorCode::InvalidParameter, "description"), 
                                    GetModuleHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
         }

         // Trace arrays
         FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, description);

         size = array_1.GetSize();
         if ( size != array_2.GetSize() || size != array_3.GetSize())
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugErrorMustHaveSameSize2);
            return;
         }

         if ( size == 0 )
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, TrStr::DebugEmptyArray);
         }

         for (index=0; index<size; index++)
         {
            FormatTrace(TrStr::DebugDEBUG, GetFunctionName(), TraceStatus::progress, 
                        "[", ToFixedWidthString(index + 1, Constants::TraceArrayIndexWidth), "]: ", 
                        ToFixedWidthString(array_1[index], Constants::TraceArrayElementWidth), " ", 
                        ToFixedWidthString(array_2[index], Constants::TraceArrayElementWidth), " ", 
                        ToFixedWidthString(array_3[index], Constants::TraceArrayElementWidth), " ",
                        ToFixedWidthString(array_4[index], Constants::TraceArrayElementWidth));
         }
      }
   }
}
#endif
#endif
