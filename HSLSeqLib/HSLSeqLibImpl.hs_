//-----------------------------------------------------
// This is a part of the HSL Sequence Library.
//
// Modification History
//-----------------------------------------------------

#ifndef __HSLSeqLibImpl_hs___
#define __HSLSeqLibImpl_hs___  1

#ifdef HSL_RUNTIME
#pragma once
#include "HSLExtensions/HSLStringTableLib.hsl"
#include "HSLStrLib/HSLStrLib.hsl"

// Implementation of Sequence library 
namespace Seq
{

   // --------------------------------------------------------------------------------------
   // Error Ids
   // --------------------------------------------------------------------------------------

   namespace IDE
   {
      static const variable first(0);                          // guard
      static const variable noError(first);                    // No error.
      static const variable openFileFailed(first + 1);         // Failed to open file: 
      static const variable last(first + 1);                   // guard
   }

   // --------------------------------------------------------------------------------------
   // String Ids
   // --------------------------------------------------------------------------------------

   namespace IDS
   {
      static const variable first(IDE::last + 1);              // guard
      static const variable helpFileName(first + 1);           // help file name
      static const variable last(first + 1);                   // guard
   }

   // --------------------------------------------------------------------------------------
   // Library Initialization 
   // --------------------------------------------------------------------------------------

   static variable initializedLib(hslFalse);                   // initialization state of the Sequence Library
   static function InitSequenceLibrary();                      // initializes the Sequence Library (only once)

   // --------------------------------------------------------------------------------------
   // Exception handling
   // --------------------------------------------------------------------------------------

   namespace Error
   {
      static function Raise(                                   // raises a runtime error
         variable errorId,                                     // i: error id, one of IDE
         variable& fileName,                                   // i: file name
         variable& funcName,                                   // i: function name
         variable& lineNumber)                                 // i: line number
      {
         variable description("");

         // set error description
         description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId);
         err.SetDescription(description);

         // raise error
         err.Raise(errorId, err.GetDescription(), StringTable::Load(IDS::helpFileName));
      }

      static function RaiseEx(
         variable errorId,
         variable errorDetail,
         variable& fileName,
         variable& funcName,
         variable& lineNumber)
      {
         variable description("");

         // set error description
         description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId) + errorDetail;
         err.SetDescription(description);

         // raise error
         err.Raise(errorId, err.GetDescription(), StringTable::Load(IDS::helpFileName));
      }
   }

   // --------------------------------------------------------------------------------------
   // Functions
   // --------------------------------------------------------------------------------------

   static function InitSequenceLibrary()
   {
      // initialize the Sequence Library once only
      if (!initializedLib)
      {
         StringTable::Init("HSLSeqLib");
         //StringTable::Dump();
         initializedLib = hslTrue;
      }
      return(initializedLib);
   }


	// Wrapper function  
	function SeqGetLabwareIds(sequence& sequenceObj, variable& labwareIds[]) variable
	{
	   return(sequenceObj.GetLabwareIds(labwareIds));
	}
	
	// Wrapper function  
	function SeqGetPositionCountForCurrLabware(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetPositionCountForCurrLabware());
	}
	
	// Wrapper function  
	function SeqGetTotal(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetTotal());
	}
	
	// Wrapper function  
	function SeqGetName(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetName());
	}
	
	// Wrapper function  
	function SeqGetNext(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetNext());
	}
	
	// Wrapper function  
	function SeqGetMax(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetMax());
	}
	
	// Wrapper function  
	function SeqSetMax(sequence& sequenceObj, variable max) variable
	{
	   return(sequenceObj.SetMax(max));
	}
	
	// Wrapper function  
	function SeqIncrement(sequence& sequenceObj, variable increment) variable
	{
	   return(sequenceObj.Increment(increment));
	}
	
	// Wrapper function  
	function SeqOperatorAssignSeq(sequence& targetSequence, sequence& sourceSequence) void
	{
	   targetSequence = sourceSequence;
	}
	
	// Wrapper function  
	function SeqCopySequence(sequence& targetSequence, sequence& sourceSequence) void
	{
	   targetSequence.CopySequence(sourceSequence);
	}
	
	// Wrapper function  
	function SeqOperatorInc(sequence& sequenceObj) variable
	{
	   return(sequenceObj++);
	}
	
	// Wrapper function  
	function SeqOperatorDec(sequence& sequenceObj) variable
	{
	   return(sequenceObj--);
	}
	
	// Wrapper function  
	function SeqRemoveAt(sequence& sequenceObj, variable position) void
	{
	   sequenceObj.RemoveAt(position);
	}
	
	// Wrapper function  
	function SeqRemoveAll(sequence& sequenceObj) void
	{
	   variable position;
	   variable total;
	   total = sequenceObj.GetTotal();
	   sequenceObj.SetCount(total);
	   sequenceObj.SetCurrentPosition(1);
	   for (position = total; 0 < position; position--)
	      sequenceObj.RemoveAt(position);
	   sequenceObj.SetCount(0);
	   sequenceObj.SetCurrentPosition(0);
	   sequenceObj.SetMax(0);
	}
	
	// Wrapper function  
	function SeqInsertAt(sequence& sequenceObj, variable position, 
	   variable& labwareId, variable& positionId) void
	{
	   sequenceObj.InsertAt(position, labwareId, positionId);
	}
	
	// Wrapper function  
	function SeqAdd(sequence& sequenceObj, variable& labwareId, variable& positionId) void
	{
	   sequenceObj.Add(labwareId, positionId);
	}
	
	// Wrapper function  
	function SeqAddEx(sequence& sequenceObj, variable& labwareId, variable& positionId, device& deviceContext) void
	{
	   sequenceObj.Add(labwareId, positionId, deviceContext);
	}
	
	// Wrapper function  
	function SeqLookupPosition(
	   sequence& sequenceObj, 
	   variable& labwareId, 
	   variable& positionId, 
	   variable start,
	   variable forward) variable
	{
	   return(sequenceObj.LookupPosition(labwareId, positionId, start, forward));
	}
	
	// Wrapper function  
	function SeqEdit(
	   sequence& sequenceObj, 
	   device& deviceContext, 
	   variable& title, 
	   variable& prompt,
	   variable timeout,
	   variable initFromCfg,
	   variable first,
	   variable last,
	   variable editable,
	   variable& cfgFile) void
	{
	   sequenceObj.Edit(deviceContext, title, prompt, timeout, initFromCfg, first, last, editable, cfgFile);
	}
	
	//>+JJ: 2005-06-13
	// Wrapper function  
	function SeqEdit2(
	   sequence& sequenceObj, 
	   device& deviceContext, 
	   variable& title, 
	   variable& prompt,
	   variable timeout,
	   variable sound,
	   variable initFromCfg,
	   sequence& editedSequenceObj, 
	   variable editable,
	   variable& cfgFile) void
	{
	   sequenceObj.Edit2(deviceContext, title, prompt, timeout, sound, initFromCfg, editedSequenceObj, editable, cfgFile);
	}
	//<+JJ: 2005-06-13
	
	
	// Wrapper function  
	function SeqGetPositionId(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetPositionId());
	}
	
	// Wrapper function  
	function SeqGetLabwareId(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetLabwareId());
	}
	
	// Wrapper function  
	function SeqGetUsedPositions(sequence& sequenceObj) variable
	{
	   return(sequenceObj.GetUsedPositions());
	}
	
	// Wrapper function  
	function SeqSetUsedPositions(sequence& sequenceObj, variable usedPositions) void
	{
	   sequenceObj.SetUsedPositions(usedPositions);
	}
	
	// Helper function  
	static function Seq__(variable& str)
	{
	   return(str);
	}
	
	// Helper function  
	// Returns the lesser of two supplied numeric (or string) expressions 
	// Identical with MthMin(), copied here to not have to include HSLMthLib.hsl 
	static function SeqMin(variable& number1, variable& number2)
	{
	   if (number1 <= number2)
	      return(number1);
	   return(number2);
	}
	
	// Break a data source name into components (file name, file extension, table name).  
	static function SeqSplitPath(
	   variable& dataSource, 
	   variable& fil, 
	   variable& ext,
	   variable& tab)
	{
	   string pathName;
	   string fileName;
	   string extension;
	   string path;
	   string table;
	   string str;
	   variable length;
	   variable offset;
	   variable index;
	
	   fil = ext = tab = "";
	   pathName = Seq__(dataSource);
	   length = pathName.GetLength();
	   index = Str::StrReverseFind(pathName, "\\");
	   path = pathName.Mid(0, index + 1);
	   fileName = pathName.Mid(index + 1, length);
	   table = fileName;
	   Str::StrTrimLeft(fileName, "");
	   Str::StrTrimRight(fileName, "");
	   offset = Str::StrReverseFind(fileName, ".");
	   str = fileName.Right(fileName.GetLength() - offset - 1);
	   index = str.Find(" ");
	   if (0 < index)
	   {
	      table = fileName.Mid(offset + index + 1, length);
	      fileName = fileName.Mid(0, offset + index + 1);
	   }
	   index = Str::StrReverseFind(fileName, ".");
	   extension = fileName.Mid(index + 1, length);
	   Str::StrTrimLeft(extension, "");
	   Str::StrTrimRight(extension, "");
	   Str::StrTrimLeft(table, "");
	   Str::StrTrimRight(table, "");
	   Str::StrTrimLeft(fileName, "");
	   Str::StrTrimRight(fileName, "");
	
	   fil = fileName;
	   tab = table;
	   ext = extension;
	
	   #ifdef _DEBUG
	   Trace("fil = ", fil);
	   Trace("tab = ", tab);
	   Trace("ext = ", ext);
	   #endif
	   
	   return;
	}
	
	// Data source containing persisted current positions of sequences 
	static file seqDS;
	
	// Saves the current position from the memory to a file data source. 
	function SeqWriteCurrentPosition(
	   variable& dataSource, 
	   variable& layoutName, 
	   variable& sequenceName, 
	   variable& currentPosition) variable
	{
	   string fileName;
	   string extension;
	   string table;
	   variable xlsDataSource;
	   variable mdbDataSource;
	   variable txtDataSource;
	   variable id(0);
	   variable lay(layoutName);
	   variable seq(sequenceName);
	   variable pos(currentPosition);
	   variable sqlStatement;
	   variable layouts[];
	
	   // initialize Sequence Library
	   InitSequenceLibrary();
	
	   SeqSplitPath(dataSource, fileName, extension, table);
	
	   xlsDataSource = ((extension.Compare("xls") == 0) || (extension.Compare("XLS") == 0));
	   mdbDataSource = ((extension.Compare("mdb") == 0) || (extension.Compare("MDB") == 0));
	   txtDataSource = (0 < table.GetLength()) && !xlsDataSource && !mdbDataSource;
	   if (txtDataSource)
	   {
	      Str::StrReplace(table, ".","#");
	      Str::StrReplace(table, ";","_");
	      Str::StrReplace(table, ":","_");
	      Str::StrReplace(table, "*","_");
	   }
	
	   sqlStatement = "SELECT * FROM [" + Seq__(table) + "] WHERE Layout ";
	   if (!mdbDataSource && "" == layoutName)
	      sqlStatement = sqlStatement + "IS NULL ";
	   else
	      sqlStatement = sqlStatement + "= '" + layoutName + "' ";
	   sqlStatement = sqlStatement + "AND Sequence = '" + sequenceName + "'";
	
	   seqDS.SetDelimiter(hslCSVDelimited);
	   seqDS.RemoveFields();
	   seqDS.AddField("Id", id, hslInteger);
	   seqDS.AddField("Layout", lay, hslString);
	   seqDS.AddField("Sequence", seq, hslString);
	   seqDS.AddField("CurrentPos", pos, hslInteger);
	   if (!seqDS.Open(dataSource, hslAppend, sqlStatement))
	      Error::RaiseEx(IDE::openFileFailed, dataSource, GetFileName(), GetFunctionName(), GetLineNumber());
	   if (xlsDataSource || mdbDataSource)
	   {
	      if (0 < seqDS.Seek(0, hslFirst))
	      {
	         sqlStatement = "UPDATE [" + Seq__(table) + "] SET CurrentPos = " + IStr(currentPosition) + " WHERE Layout ";
	         if (!mdbDataSource && "" == layoutName)
	            sqlStatement = sqlStatement + "IS NULL ";
	         else
	            sqlStatement = sqlStatement + "= '" + layoutName + "' ";
	         sqlStatement = sqlStatement + "AND Sequence = '" + sequenceName + "'";
	
	         seqDS.Open(dataSource, hslAppend, sqlStatement);
	      }
	      else
	      {
	         sqlStatement = "SELECT * FROM [" + Seq__(table) + "] ORDER BY Id ASC";
	         seqDS.Open(dataSource, hslAppend, sqlStatement);
	         if (0 < seqDS.Seek(0, hslLast))
	            seqDS.ReadRecord();
	         id = ++id;
	         lay = layoutName;
	         seq = sequenceName;
	         pos = currentPosition;
	         seqDS.WriteRecord();
	      }
	   }
	   else
	   {
	      if (0 < seqDS.Seek(0, hslFirst))
	      {
	         variable index;
	         variable upperBound;
	         variable ids[];
	         variable sequences[];
	         variable positions[];
	         seqDS.Open(dataSource, hslAppend);
	         while (!seqDS.Eof())
	         {
	            seqDS.ReadRecord();
	            ids.AddAsLast(id);
	            // the ISAM driver for text files returns a value 
	            // of type VT_NULL instead of an empty string of type VT_BSTR 
	            // -> so be prepared to handle a typeless variable 'lay'.
	            if (IsDBNull(lay))
	            {
	               lay = "";
	            }
	            layouts.AddAsLast(lay);
	            sequences.AddAsLast(seq);
	            if (layoutName == lay && sequenceName == seq)
	               positions.AddAsLast(currentPosition);
	            else
	               positions.AddAsLast(pos);
	         }
	         seqDS.Open(dataSource, hslWrite);
	         upperBound = SeqMin(SeqMin(layouts.GetSize(), sequences.GetSize()), positions.GetSize());
	         for (index = 0; index < upperBound; index++)
	         {
	            id = ids.ElementAt(index);
	            lay = layouts.ElementAt(index);
	            seq = sequences.ElementAt(index);
	            pos = positions.ElementAt(index);
	            seqDS.WriteRecord();
	         }
	      }
	      else
	      {
	         sqlStatement = "SELECT * FROM [" + Seq__(table) + "] ORDER BY Id ASC";
	         seqDS.Open(dataSource, hslAppend, sqlStatement);
	         if (0 < seqDS.Seek(0, hslLast))
	            seqDS.ReadRecord();
	         id = ++id;
	         lay = layoutName;
	         seq = sequenceName;
	         pos = currentPosition;
	         seqDS.WriteRecord();
	      }
	   }
	   return(hslTrue);
	}
	
	// Loads the current position from a file data source into memory. 
	function SeqReadCurrentPosition(
	   variable& dataSource, 
	   variable& layoutName, 
	   variable& sequenceName) variable
	{
	   string fileName;
	   string extension;
	   string table;
	   variable xlsDataSource;
	   variable mdbDataSource;
	   variable txtDataSource;
	   variable pos(-1);
	   variable sqlStatement;
	
	   SeqSplitPath(dataSource, fileName, extension, table);
	
	   xlsDataSource = ((extension.Compare("xls") == 0) || (extension.Compare("XLS") == 0));
	   mdbDataSource = ((extension.Compare("mdb") == 0) || (extension.Compare("MDB") == 0));
	   txtDataSource = (0 < table.GetLength()) && !xlsDataSource && !mdbDataSource;
	   if (txtDataSource)
	   {
	      Str::StrReplace(table, ".","#");
	      Str::StrReplace(table, ";","_");
	      Str::StrReplace(table, ":","_");
	      Str::StrReplace(table, "*","_");
	   }
	
	   sqlStatement = "SELECT CurrentPos FROM [" + Seq__(table) + "] WHERE Layout ";
	   if (!mdbDataSource && "" == layoutName)
	      sqlStatement = sqlStatement + "IS NULL ";
	   else
	      sqlStatement = sqlStatement + "= '" + layoutName + "' ";
	   sqlStatement = sqlStatement + "AND Sequence = '" + sequenceName + "'";
	
	   seqDS.SetDelimiter(hslCSVDelimited);
	   seqDS.RemoveFields();
	   seqDS.AddField("CurrentPos", pos, hslInteger);
	   if (!seqDS.Open(dataSource, hslRead, sqlStatement))
	      return(-2);
	   while (!seqDS.Eof())
	   {
	      seqDS.ReadRecord();
	   }
	   return(pos);
	}
	
	// Wrapper function  
	function SeqReadFromFile(
	   sequence& sequenceObj, 
	   device& deviceContext, 
	   variable indexesOnly, 
	   variable& cfgFile)   variable
	{
	   return(sequenceObj.ReadFromFile(deviceContext, indexesOnly, cfgFile));
	}
	
	// Wrapper function  
	function SeqWriteToFile(
	   sequence& sequenceObj, 
	   device& deviceContext, 
	   variable indexesOnly, 
	   variable& cfgFile) void
	{
	   sequenceObj.WriteToFile(deviceContext, indexesOnly, cfgFile);
	}
	
	//New Function, 384 sort with MPH48 (sort like a 96):                                              
	function SeqMPH48SortLike96(
	   sequence& sequenceObj, 
	   variable Q1,
	   variable Q2,
	   variable Q3,
	   variable Q4) variable
	{
	   sequence tempsequence;
	   variable checklength;
	   string   labwarename;
	   variable labwarenames[];
	   variable quadrant;
	   variable currentquadrant;
	   variable position;
	   string   strposition;
	   variable offset;
	   variable total;
	   variable persistoffset;
	   variable innerloop;
	   variable outerloop;
	   variable LoopCtr01;
	   variable NumberOfPlates;
	   variable ErrStatus01;
	
	   //Make a copy of the sequence object to tempsequence:
	   tempsequence.CopySequence( sequenceObj);
	
	
	   //first check that the sequence is > 383
	   checklength = sequenceObj.GetTotal();
	   if ( checklength < 384 )
	      {
	         return (0);
	      }
	
	
	   if ( checklength >= 384 ) //Case is for valid length sequences:
	
	   {
	         NumberOfPlates = checklength/384;
	         ErrStatus01 = sequenceObj.GetLabwareIds(labwarenames);
	
	         //Copy the "remove all positions" routine:
	            total = tempsequence.GetTotal();
	            tempsequence.SetCount(total);
	            tempsequence.SetCurrentPosition(1);
	            for (position = total; 0 < position; position--)
	               tempsequence.RemoveAt(position);
	            tempsequence.SetCount(0);
	            tempsequence.SetCurrentPosition(0);
	            tempsequence.SetMax(0);
	
	         // Loop over all positions, 384 positions at a time:
	         for ( LoopCtr01 = 0; LoopCtr01 < NumberOfPlates ; LoopCtr01++)
	         {
	         labwarename = labwarenames.GetAt( LoopCtr01 );
	
	         //Loop over four quadrants, setting start for each
	         for (quadrant = 1; quadrant < 5; quadrant++)
	            {
	            //Which rep of 4 are we on?
	            if ( quadrant == 1 )
	            currentquadrant = Q1;
	            if ( quadrant == 2 )
	            currentquadrant = Q2;      
	            if ( quadrant == 3 )
	            currentquadrant = Q3;
	            if ( quadrant == 4 )
	            currentquadrant = Q4;
	
	            //What is the starting position for this repitition?
	            if (currentquadrant == "A1")
	            {
	               position = 1;
	               offset = 1;
	            }
	            if (currentquadrant == "A2")
	            {
	               position = 2;
	               offset = 2;
	            }
	            if (currentquadrant == "B1")
	            {
	               position = 25;
	               offset = 25;
	            }
	            if (currentquadrant == "B2")
	            {
	               position = 26;
	               offset = 26;
	            }
	   
	            //Calculate the persistent offset for right/upper half of sequence:
	
	            persistoffset = offset + 12;
	
	            //Produce first 48 of new sequence:
	            for(outerloop = 0; outerloop < 8; outerloop++)
	               {
	               for(innerloop = 0; innerloop < 6; innerloop++)
	                  {
	                  strposition = IStr( position );
	                  tempsequence.Add(labwarename, strposition);
	                  position = position + 2;
	                  }
	               position = (48 * outerloop) + offset;
	               }
	
	            //Calculate offsets and produce second 48 of new sequence:
	         position = persistoffset;
	         offset = persistoffset;
	
	            for(outerloop = 0; outerloop < 8; outerloop++)
	               {
	               for(innerloop = 0; innerloop < 6; innerloop++)
	                  {
	                     strposition = IStr( position );
	                     tempsequence.Add(labwarename, strposition);
	                     position = position + 2;
	                  }
	                  position = (48 * outerloop) + offset;
	               }
	         }  //End of LOOP over quadrant
	      }     //End of FOR loop over plates
	   }        //End of IF for multiple plates
	
	
	
	
	   //Set new sequence's pointer to 1:
	         sequenceObj.CopySequence( tempsequence );
	         sequenceObj.SetCurrentPosition(1);
	         return (1);
	
	}
	
	// Wrapper function  
	function SeqEqualSequences(sequence& sequenceObj_1, sequence& sequenceObj_2) variable
	{
	   return(sequenceObj_1.EqualsToSequence(sequenceObj_2));
	}
	
	//  Resets all sequence indexes
	function SeqResetSequenceIndexes(sequence& sequenceObj) void
	{
	   sequenceObj.SetCount(sequenceObj.GetTotal());
	   sequenceObj.SetCurrentPosition(1);
	   sequenceObj.SetMax(sequenceObj.GetTotal());
	}
	
	// Wrapper function  
	function SeqSetProperty(
	   sequence& sequenceObj, 
	   variable position, 
	   variable& propertyName, 
	   variable& propertyValue) void
	{
	   sequenceObj.SetSequenceProperty(position, propertyName, propertyValue);
	}
	
	// Wrapper function  
	function SeqSetPropertyRange(
	   sequence& sequenceObj, 
	   variable startPosition, 
	   variable endPosition, 
	   variable& propertyName, 
	   variable& propertyValue) void
	{
	   sequenceObj.SetSequencePropertyRange(startPosition, endPosition, propertyName, propertyValue);
	}
	
	// Wrapper function  
	function SeqGetProperty(
	   sequence& sequenceObj, 
	   variable position, 
	   variable& propertyName) variable
	{
	   return(sequenceObj.GetSequenceProperty(position, propertyName));
	}
	
	// Wrapper function  
	function SeqRemoveProperty(
	   sequence& sequenceObj, 
	   variable position, 
	   variable& propertyName) void
	{
	   sequenceObj.RemoveSequenceProperty(position, propertyName);
	}
	
	// Wrapper function  
	function SeqRemoveAllProperties(
	   sequence& sequenceObj, 
	   variable position) void
	{
	   sequenceObj.RemoveAllSequenceProperties(position);
	}
}
#endif
#endif
